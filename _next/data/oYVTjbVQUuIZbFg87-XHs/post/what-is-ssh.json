{"pageProps":{"frontmatter":{"title":"SSH란❓","description":"SSH에 대한 정리글","date":"March 9, 2021","tags":["network","ssh"]},"post":{"content":"\n![ssh](ssh.png)\n\n원격 서버에 ssh를 이용해 접속을 많이 했지만, 정확히 이게 어떤 것인지 잘 모르고 썼었던 것 같아 조사하여 정리해보았다.\n\n**SSH**는 리눅스 서버에 원격으로 접속하기 위해 사용하는 보안 프로토콜을 의미한다. Telnet이나 rsh같이 보안에 취약한 다른 원격 프로토콜들을 대체한, 현재 가장 보편적인 원격 접속 프로토콜이다. SSH는 패킷을 암호화하여 인터넷같이 보안되지 않는 네트워크 속에서도 안전한 연결을 제공한다.\n\n<hr>\n\n# **SSH Work Flow**\n\n## **연결 시작**\n\nSSH 연결은 클라이언트에 의해 시작된다. 클라이언트는 서버의 ssh 포트에 TCP 연결을 하게 되고, ssh 프로토콜 버전과 ssh 서버의 package 버전을 얻게 된다. 만약 클라이언트와 프로토콜 버전이 같다면 연결을 진행하고, 아니라면 연결을 끊는다.\n\n## **클라이언트의 서버 검증**\n\n클라이언트가 프로토콜 버전을 확인한 후 연결을 지속하기로 하면, 서버는 이제 클라이언트에게 **공개 키**를 건네준다. 만약 서버와 클라이언트가 처음 연결한다면, 클라이언트는 다음과 같은 경고 메시지를 받는다.\n\n```bash\nThe authenticity of host '[ip]:[port]' can't be established.\nRSA key fingerprint is [server's public key].\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n```\n\n연결을 한번 하고 나면 해당 키는 클라이언트의 `~/.ssh/known_hosts`파일에 저장되어 이후 해당 서버에 접속시엔 클라이언트가 해당 파일을 참고하여 서버를 확인하므로 경고 없이 연결된다.\n\n## **세션 키 생성**\n\n서버를 확인하고 나면, 서버와 클라이언트는 [Diffie-Hellman 알고리즘](https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A8%BC_%ED%82%A4_%EA%B5%90%ED%99%98)을 이용해 같이 **세션 키**를 만든다(SSH 버전 2 기준이며, 버전 1은 다른 방식으로 서버 혼자 세션 키를 만든다). 이렇게 만들어진 세션 키는 대칭 키(암호화와 복호화에 같은 키를 사용한다)이며, 앞으로 클라이언트와 서버간의 모든 통신을 암호화, 복호화하는데 사용된다.\n\n## **클라이언트 인증**\n\n마지막으로는, 클라이언트의 인증 과정을 거친다. 인증은 **password 방식**과 **key 방식**이 있다.\n\n🔢 **Password로 인증**\n\npassword 인증은 key방식에 비해 간단하다. 클라이언트는 로그인을 원하는 계정의 비밀번호를 입력하여 접속한다. 이 때 전송되는 password는 Step 3에서 만들어낸 세션 키로 암호화되어 전송되기 때문에 안전하다.\n\n🔑 **Key로 인증**\n\n인증은 [공개키 암호 방식](https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D)으로 진행된다. 암호화에 사용되며 누구에게나 공유 가능한 **공개키(Public key)** 와, 복호화에 사용되고 아무에게도 공유해서는 안 되는 **개인 키(Private key)** 를 이용해 암호화를 진행한다.\n\n과정은 다음과 같다.\n\n1. 클라이언트는 서버에 공개 키를 보낸다.\n2. 서버는 클라이언트가 공개 키로 접속하길 원하는 계정의 `~/.ssh/authorized_keys` 파일을 참고한다.\n3. 해당 키가 파일에 존재한다면, 서버는 생성한 난수로 공개 키를 암호화한 후 클라이언트로 보낸다.\n4. 만약 클라이언트가 공개키와 쌍인 개인 키를 가지고 있으면, 클라이언트는 해당 메시지를 풀어서 서버가 만들어낸 난수를 알게 된다.\n5. 클라이언트는 알게 된 난수와, 앞서 공유한 세션 키를 연산하여 해당 값의 [MD5](https://ko.wikipedia.org/wiki/MD5) Hash 값을 계산한다.\n6. 클라이언트는 이 MD5 Hash를, 서버의 요청에 대한 답으로 보낸다.\n7. 서버도 마찬가지로 세션 키와 난수를 이용하여 MD5 Hash 값을 스스로 계산하고, 이 값과 클라이언트가 보낸 값을 비교한다. 만약 두 값이 일치하면 클라이언트의 인증이 완료된다.\n\n## **인증 완료**\n\n모든 인증이 완료되면, 클라이언트와 서버의 연결이 수립된다.\n\n앞으로의 모든 통신은 Step 3에서 만들어낸 세션키로 암호화된 보안 채널을 통해 이루어진다. 공개키 암호화 방식은 대칭키 방식보다 비용이 많이 들기 때문에 세션 키를 이용하여 암호화와 복호화를 진행한다.\n\n<hr>\n\n# **SSH Key로 인증하기**\n\n이제 패스워드 대신 키를 이용해 원격 서버에 인증하는 방법을 살펴보자\n\n## **RSA 키 생성**\n\n대부분의 OS에는 OpenSSH라는 ssh client 프로그램이 설치되어 있는데, OpenSSH로 쉽게 key pair를 만들 수 있다. 먼저 터미널을 열고 아래 커맨드를 입력한다.\n\n```bash\n$ ssh-keygen -t rsa\n```\n\n`-t`는 key 타입을 지정하는 옵션이며, rsa1, rsa, dsa 총 3가지가 있다.\n\nrsa1은 프로토콜 버전 1을 위한 것이며 rsa와 dsa는 버전 2를 위한 것인데, 현재 버전1은 거의 없으며 dsa보다는 rsa를 사용할 것이 권장되므로 rsa 타입으로 key를 만든다.\n\n## **키 저장 및 비밀번호 설정**\n\n위의 커맨드를 입력하면 다음과 같은 질문이 나온다.\n\n```bash\nEnter file in which to save the key (~/.ssh/id_rsa):\n```\n\n바로 `Enter`를 입력하게 되면 옆에 표시된 위치에 key가 저장되고, 아니면 직접 경로를 입력하면 된다.\n\n```bash\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n```\n\n그리고 나면 암호를 입력하라는 메시지가 뜬다. 암호를 설정하게 되면, 개인 키를 사용할 때 마다 암호를 입력해야 하는 단점이 있지만 좀 더 안전하다.\n\n만약 설정하기 싫다면 바로 `Enter`를 입력하면 된다.\n\n암호 설정까지 마치면, 지정했던 경로에 public key는 `id_rsa.pub`으로, private key는 `id_rsa`로 저장되어 있다.\n\n## **원격 서버에 공개 키 복사하기**\n\n이제 키 생성을 마치고 나면, 접속을 원하는 서버의 `~/.ssh/authorized_keys` 파일에 공개 키를 복사해놓으면 된다.\n\n아래처럼 `ssh-copy-id` 커맨드를 사용하거나\n\n```bash\n# -i option으로 공개 키 경로를 지정하면 된다.\n$ ssh-copy-id -i ~/.ssh/id_rsa.pub username@ip-address\n```\n\n또는 `ssh` 커맨드를 이용하여 복사할 수 있다.\n\n```bash\n$ cat ~/.ssh/id_rsa | ssh username@ip-address \"mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >>  ~/.ssh/authorized_keys\"\n```\n\n위의 두 방법 말고도, 직접 복사를 할수도 있다.\n\n아래 커맨드를 입력하여, 복사를 원하는 공개 키의 내용을 확인하고 `~/.ssh/authorized_keys`파일에 수동으로 붙여넣으면 된다.\n\n```bash\n$ cat ~/.ssh/id_rsa.pub\n```\n\n만약 원격 서버에 `~/.ssh`폴더가 없다면, 폴더를 생성한 후 파일을 만들어 키를 복사한다.\n\n```bash\n$ mkdir -p ~/.ssh\n$ echo [public key string] >> ~/.ssh/authorized_keys\n```\n\n위의 과정을 거쳐 서버에 공개 키를 복사하고 나면, 다음 커맨드로 비밀번호 없이 접속이 가능하다.\n\n```bash\n$ ssh username@ip-address\n```\n\n<hr>\n\n# **References**\n\n[SSH Essentials: Working with SSH Servers, Clients, and Keys](https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys)\n\n[Wikipedia: SSH (Secure Shell)](<https://en.wikipedia.org/wiki/SSH_(Secure_Shell)>)\n\n[Understanding SSH workflow](https://medium.com/@Magical_Mudit/understanding-ssh-workflow-66a0e8d4bf65#:~:text=SSH%20protocol%20uses%20symmetric%20encryption,to%20encrypt%20all%20the%20communication)\n\n[How To Set Up SSH Keys](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-2#step-two%E2%80%94store-the-keys-and-passphrase)\n\n<br>\n\n혹시 내용에 오류가 있을 경우 댓글로 알려주세요 🙂\n","excerpt":""},"previousPost":null,"nextPost":{"slug":"referencing-a-commit","frontmatter":{"title":"Git 커밋 가리키기","description":"커밋을 가리키는 다양한 방법들","date":"May 17, 2021","tags":["git"]},"excerpt":"","content":"\n# SHA-1 해시로 가리키기\n\n커밋마다 각자 고유한 해시값을 지니는데, 이 해시값으로 커밋을 가리킬 수 있다.\n\n`git log`를 하면 해당 커밋 로그가 나오는데, commit 문자 옆에 써진 엄청 긴 `ca82a6dff817...`(생략)과 같은 문자가 바로 SHA-1해시이다.\n\n💡 SHA-1 해시를 전부 다 쓰지 않고 줄여 써도 커밋을 가리킬 수 있다. 줄인 해시가 중복되지 않았다는 가정하에, 최소 4개의 문자를 쓰면 가리킬 수 있다. (ex. `git show ca82`).\n\n```bash\n# git show 명령은 해당 커밋의 정보를 보여주는 명령어이다.\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show ca82\n```\n\n---\n\n# 브랜치로 가리키기\n\n브랜치 이름으로도 커밋을 가리킬 수 있다. 따라서 아래 두 명령의 결과는 같다.\n\n```bash\n$ git show ca82a6dff817ec66f44342007202690a93763949\n\n# main이 ca82a6d... 커밋을 가리키고 있다고 가정\n$ git show main\n```\n\n---\n\n# `@{n}` : Reflog로 가리키기\n\nGit은 자동으로 브랜치와 HEAD가 지난 몇 달 동안에 가리켰었던 커밋을 모두 기록하는데 이 로그를 `Reflog`라고 한다.\n\n`Reflog`는 `git reflog`명령어를 실행하면 볼 수 있다.\n\n```bash\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n...\n```\n\nGit은 `reflog`에서 보는 것 처럼, 이전에 가리키던 것이 무엇인지 확인할 수 있기 때문에 `@{n}` 규칙을 사용하면 브랜치나 HEAD가 n번 전에 가리켰던 것을 알 수 있다.\n\n```bash\n$ git show HEAD@{3}\n$ git show main@{2}\n```\n\n커밋 순서가 아닌 시간으로도 가리킬 수 있다.\n\n`{yesterday}`, `{1 month 2 weeks 3 days 1 hour 1 second ago}`, `{1979-02-26 18:30:00}` 와 같은 포맷들이 가능하다.\n\n```bash\n$ git show main@{5 minutes ago}\n\n$ git show main@{yesterday}\n$ git show main@{3.days.ago} # dot도 가능\n\n$ git show main@{one.week.ago}\n$ git show main@{1 weeks ago}\n\n$ git show main@{2.month.ago}\n```\n\n---\n\n# `^` : 부모 커밋 가리키기\n\n`HEAD^` 와 같은 형태로 쓴다. HEAD대신 커밋을 의미하는 어떤 문자도 들어갈 수 있다.\n\n`^`를 여러번 쓸 수도 있다. ex) `HEAD^^`(조부모), `HEAD^^^`(조부모의 부모), ...\n\n단, `HEAD^2` 처럼, `^` 와 숫자가 같이 붙는 경우엔, 해당 커밋의 부모를 선택할 수있다.\n\n그래서 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다. 첫 번째 부모는 Merge했을 때 기준이 된 branch를 의미하고, 두 번째 부모는 Merge하고자 하는 branch를 의미한다.\n\n```bash\nA - B - C <- (HEAD, main)\n     \\_ D <- (issue1)\n\n$ git merge issue1\n\nA - B - C - E (HEAD, main)\n     \\_ D _/\n     (issue1)\n\n$ git checkout HEAD^2 # issue1으로 HEAD가 이동\n```\n\n---\n\n# `~` : 위로 n번째 부모 커밋 가리키기\n\n여러 단계의 부모 커밋으로 올라가고 싶을 때, `^`를 여러번 쓰기 보단, 수를 지정해서 올라가는 것이 편한데 이럴 때 사용한다.\n\n`HEAD~`(부모 커밋), `HEAD~3` 과 같은 식으로 쓸 수 있다.\n\n그리고 `^`과 `~`수식은 `HEAD~^2^^`와 같은 형식으로 다같이 사용할 수 있다.\n\n## 표현 예제\n\n아래는 `~`와 `^`를 사용해 커밋들을 표현하는 예제이다. 해당 그림은 git 홈페이지의 gitrevisions에서 좋은 예제인 것 같아 가져왔다.\n\n```bash\nG   H   I   J\n \\ /     \\ /\n  D   E   F\n   \\  |  / \\\n    \\ | /   |\n     \\|/    |\n      B     C\n       \\   /\n        \\ /\n         A\n\nA =      = A^0\nB = A^   = A^1     = A~1\nC =      = A^2\nD = A^^  = A^1^1   = A~2\nE = B^2  = A^^2\nF = B^3  = A^^3\nG = A^^^ = A^1^1^1 = A~3\nH = D^2  = B^^2    = A^^^2  = A~2^2\nI = F^   = B^3^    = A^^3^\nJ = F^2  = B^3^2   = A^^3^2\n```\n\n---\n\n# 범위로 커밋 가리키기\n\n범위를 주고 여러 커밋을 조회할 때 사용한다.\n\n## `..` : 두 브랜치의 차집합 커밋\n\n`{A}..{B}`형태로 쓰며, A에는 없지만 B에는 있는 커밋을 조회한다.\n\n같은 브랜치인 경우 A~B까지의 커밋을 조회한다고 생각하면 된다.\n\n```bash\nA - B - E - F <- main\n    \\ _ C - D <- experiment\n\n$ git log main..experiment # main 브랜치에는 없지만 experiment에만 있는 커밋\nD\nC\n\n$ git log experiment..main # experiment에는 없지만 main에만 있는 커밋\nF\nE\n\n$ git log main^^..main # main^^~main까지의 커밋\nF\nE\n\n$ git log main..main^^ # ouptut 없음\n```\n\n## `...` : 두 브랜치의 (합집합 - 교집합) 커밋\n\n`{A}...{B}`형태로 쓰며, A와 B 두 브랜치 사이에서 공통 부분을 제외한 나머지 커밋들을 보여준다.\n\n```bash\nA - B - E - F <- main\n    \\ _ C - D <- experiment\n\n$ git log master...experiment\nF\nE\nD\nC\n\n$ git log master^^...master\nF\nE\n\n$ git log master...master^^\nF\nE\n```\n\n---\n\n# References\n\n[Pro Git](https://git-scm.com/book/en/v2)\n"}},"__N_SSG":true}